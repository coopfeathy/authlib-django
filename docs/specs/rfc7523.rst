.. _specs/rfc7523:

JWT Profile for OAuth 2.0 Client Authentication and Authorization Grants
========================================================================

.. meta::
    :description: API references on RFC7523 JWT Bearer Grant of Python
        implementation, guide on how to create a server that support
        JWT profile for OAuth 2.0 client authentication and authorization
        grants.

This section contains the generic Python implementation of RFC7523_.

.. _RFC7523: https://tools.ietf.org/html/rfc7523

.. module:: authlib.specs.rfc7523


Using JWTs as Authorization Grants
----------------------------------

JWT Profile for OAuth 2.0 Authorization Grants works in the same way with
:ref:`RFC6749 <specs/rfc6749>` built-in grants. Which means it can be
registered with :meth:`~authlib.specs.rfc6749.AuthorizationServer.register_grant`.

The base class is :class:`JWTBearerGrant`, you need to implement the missing
methods in order to use it. Here is an example::

    from authlib.specs.rfc7519 import jwk
    from authlib.specs.rfc7523 import JWTBearerGrant as _JWTBearerGrant

    class JWTBearerGrant(_JWTBearerGrant):
        def authenticate_user(self, claims):
            # get user from claims info, usually it is claims['sub']
            # for anonymous user, return None
            return None

        def authenticate_client(self, claims):
            # get client from claims, usually it is claims['iss']
            # since the assertion JWT is generated by this client
            return get_client_by_iss(claims['iss'])

        def resolve_public_key(self, headers, payload):
            # get public key to decode the assertion JWT
            jwk_set = get_client_public_keys(claims['iss'])
            return jwk.loads(jwk_set, header.get('kid'))

    # register grant to authorization server
    authorization_server.register_grant(JWTBearerGrant)

When creating a client, authorization server will generate several key pairs.
The server itself can only keep the public keys, which will be used to decode
assertion value.

For **client implementation**, check out :class:`~authlib.client.AssertionSession`.

.. _jwt_client_authentication:

Using JWTs for Client Authentication
------------------------------------

In :ref:`specs/rfc6749`, Authlib provided three built-in client authentication
methods, which are ``none``, ``client_secret_post`` and ``client_secret_basic``.
With the power of Assertion Framework, we can add more client authentication
methods. In this section, Authlib provides two more options:
``client_secret_jwt`` and ``private_key_jwt``. RFC7523 itself doesn't define
any names, these two names are defined by OpenID Connect in ClientAuthentication_.

The :class:`~authlib.specs.rfc6749.AuthorizationServer` has provided a method
:meth:`~authlib.specs.rfc6749.AuthorizationServer.register_client_auth_method`
to add more client authentication methods.

client_secret_jwt
~~~~~~~~~~~~~~~~~

This authentication is provided by :class:`ClientSecretJWT`, but you need to
implement the missing methods at first::

    class MyClientSecretJWT(ClientSecretJWT):
        def validate_jti(self, claims, jti):
            # use cache to validate jti value
            key = 'jti:{}-{}'.format(claims['sub'], jti)
            if cache.get(key):
                return False
            cache.set(key, 1, timeout=3600)
            return True

    authorization_server.register_client_auth_method(
        MyClientSecretJWT.CLIENT_AUTH_METHOD,
        MyClientSecretJWT('https://example.com/oauth/token')
    )

The value ``https://example.com/oauth/token`` is your authorization servers's
token endpoint, which is used as ``aud`` value in JWT.

private_key_jwt
~~~~~~~~~~~~~~~

This authentication is provided by :class:`PrivateKeyJWT`, it is a subclass
of :class:`ClientSecretJWT`::

    class MyPrivateKeyJWT(PrivateKeyJWT):
        def validate_jti(self, claims, jti):
            # use cache to validate jti value
            key = 'jti:{}-{}'.format(claims['sub'], jti)
            if cache.get(key):
                return False
            cache.set(key, 1, timeout=3600)
            return True

        def resolve_client_public_key(self, client, headers):
            # the JWT assertion is signed by client's secret key
            # we need to use client's public key to verify the signature
            # how to store client's public key is decided by you
            return client.public_key

    authorization_server.register_client_auth_method(
        MyPrivateKeyJWT.CLIENT_AUTH_METHOD,
        MyPrivateKeyJWT('https://example.com/oauth/token')
    )

.. _ClientAuthentication: http://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication


API Reference
-------------

.. autoclass:: JWTBearerGrant
    :member-order: bysource
    :members:

.. autoclass:: JWTBearerClientAssertion
    :member-order: bysource
    :members:

.. autoclass:: ClientSecretJWT
    :member-order: bysource
    :members:

.. autoclass:: PrivateKeyJWT
    :member-order: bysource
    :members:
    :inherited-members:
